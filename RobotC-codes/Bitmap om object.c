
#pragma config(Sensor, S1,     color_sensor,   sensorColorNxtRED)
#pragma config(Sensor, S2,     light_sensor,   sensorLightActive)
#pragma config(Sensor, S3,     sonar,          sensorSONAR)
#pragma config(Motor,  motorA,          motor_right,   tmotorNXT, PIDControl, driveLeft, encoder)
#pragma config(Motor,  motorB,          motor_left,    tmotorNXT, PIDControl, driveRight, encoder)
//*!!Code automatically generated by 'ROBOTC' configuration wizard               !!*//

#pragma platform(NXT)
//*!!Code automatically generated by 'ROBOTC' configuration wizard               !!*//

//long nLastXmitTimeStamp = nPgmTime;
//long nDeltaTime = 0;

//const int kMaxSizeOfMessage = 30; //create a variable for the maximum message size
//const int INBOX = 5;

//variables for setting the minimum and maximum values of the light sensor and colorsensor
int maxcolor = 56;
int mincolor = 20;
int maxlight = 69;
int minlight = 34;
int speed = 30;
int counter = 0;
int tellen = 0;
//int i,j;
int holding1,holding2;
int startrow, startcollumn;
int endrow, endcollumn;
int currentrow,currentcollumn;
int currentjunctionrow = 0,currentjunctioncollumn = 0;
int around_object = 0;
int junction_counter = 0;
char first_junction = '0';
char new_matrix[20];
char turn_left = 'L';
char turn_right = 'R';
char up = 'U';
char down = 'D';
void steering_sideways();
void finding_route();

int matrix[11][11] =				{   {0,1,0,1,0,1,0,1,0,1,0},
                                {1,4,1,4,1,4,1,4,1,4,1},
                                {0,1,0,1,0,1,0,1,0,1,0},
                                {1,4,1,4,1,4,1,4,1,4,1},
                                {0,1,0,1,0,1,0,1,0,1,0},
                                {1,4,1,4,1,4,1,4,1,5,1},
                                {0,1,0,1,0,1,0,1,0,1,0},
                                {1,4,1,4,1,4,1,4,1,4,1},
                                {0,1,0,1,0,1,0,1,0,1,0},
                                {1,4,1,4,1,4,1,4,1,4,1},
                                {0,1,0,2,0,1,0,1,0,1,0}};

int junctions[20][2];

char instructions[20];

/*void speed_adjust(int index, int until, int increment) {

            This function is used for slowing down the motor slowly instead of stopping immediatly

    for (int i = index; i >= until; i += increment) {
        setMultipleMotors(i, motorA, motorB);
        wait(0.09);
    }
}
*/

void saving_junction(int currentjunctionrow, int currentjunctioncollumn){
    junctions[junction_counter][0] = currentjunctionrow;
    junctions[junction_counter][1] = currentjunctioncollumn;
    junction_counter++;
}

void left(){
        turn_left = 'U';
        turn_right = 'D';
        up = 'R';
        down = 'L';
}
void right(){
    turn_right = 'U';
    turn_left = 'D';
    up = 'L';
    down = 'R';
}

void up_settings(){
    turn_right = 'R';
    turn_left = 'L';
    up = 'U';
    down = 'D';
}

void adding_instructions(char first_junction){
    instructions[tellen] = first_junction;
    tellen++;
}

void down_setting(){
    turn_left =  'R';
    turn_right = 'L';
    up = 'D';
    down = 'U';
}

void adjusting_for_object(){
			currentjunctionrow = junctions[counter][0];
			currentjunctioncollumn = junctions[counter][1];
			char direction = 'U';
			for(int i = 0; i <= counter; i++){
					if(new_matrix[i] == 'L'){
						direction = 'L';
					}else if(new_matrix[i] == 'R'){
						direction = 'R';
					}

			}
			matrix[startrow][startcollumn] = 1;
			if(direction == 'R'){
				right();
				matrix[currentjunctionrow][currentjunctioncollumn -1] = 2;
				if(instructions[counter] == 'r'){
						matrix[currentjunctionrow][currentjunctioncollumn + 1] = 0;
				}else if(instructions[counter] == 'u'){
						matrix[currentjunctionrow + 1][currentjunctioncollumn] = 0;
				}else if(instructions[counter] == 'd'){
						matrix[currentjunctionrow - 1][currentjunctioncollumn] = 0;
				}

			}else if(direction == 'L'){
				left();
				matrix[currentjunctionrow][currentjunctioncollumn + 1] = 2;
				if(instructions[counter] == 'l'){
						matrix[currentjunctionrow][currentjunctioncollumn - 1] = 0;
				}else if(instructions[counter] == 'u'){
						matrix[currentjunctionrow + 1][currentjunctioncollumn] = 0;
				}else if(instructions[counter] == 'd'){
						matrix[currentjunctionrow - 1][currentjunctioncollumn] = 0;
				}
			}else if(new_matrix[counter-1] == 'U'){
				up_settings();
				matrix[currentjunctionrow+1][currentjunctioncollumn] = 2;
				if(instructions[counter] == 'u'){
					matrix[currentjunctionrow - 1][currentjunctioncollumn] = 0;
				}else if(instructions[counter] == 'l'){
					left();
					matrix[currentjunctionrow][currentjunctioncollumn - 1] = 0;
				}else if(instructions[counter] == 'r'){
					right();
					matrix[currentjunctionrow][currentjunctioncollumn + 1] = 0;
				}



}}


void calculate(int i){
    while(instructions[i] != '0'){
        if(instructions[i] == 'l'){
            new_matrix[i] = turn_left;
            left();
            i++;
            while(1){
            if((instructions[i] != 'u') && (instructions[i] != '0')){
                if(instructions[i] == 'l'){
                    new_matrix[i] = turn_left;
                }else if(instructions[i] == 'r'){
                    new_matrix[i] = turn_right;
                }else if(instructions[i] == 'd'){
                    new_matrix[i] = down;
                    down_setting();
                }else if(instructions[i] == '0'){
                            break;
                        }
                i++;
            }else{
                new_matrix[i] = up;
                i++;
                up_settings();
                break;
            }}
        }else if((instructions[i] == 'r') && (instructions[i] != '0')){
            new_matrix[i] = turn_right;
            right();
            i++;
            while(1){
                if(instructions[i] != 'u'){
                        if(instructions[i] == 'l'){
                            new_matrix[i] = turn_left;
                        }else if(instructions[i] == 'r'){
                            new_matrix[i] = turn_right;
                        }else if(instructions[i] == 'd'){
                            new_matrix[i] = down;
                            down_setting();
                        }else if(instructions[i] == '0'){
                            break;
                        }
                i++;
                }else if(instructions[i] == 'u'){
                    new_matrix[i] = up;
                    i++;
                    up_settings();
                    break;
                }
            }
        }else if((instructions[i] == 'u') && (instructions[i] != '0')){
            new_matrix[i] = up;
            i++;
        }
    }
}


void steering_sideways(){
    if(currentcollumn < endcollumn){ //++
			if(matrix[currentrow][currentcollumn+1] == 1){
				currentcollumn++;
                adding_instructions('r');
			}else if(matrix[currentrow][currentcollumn+1] == 4){
                currentcollumn++;
                currentjunctionrow = currentrow;
                currentjunctioncollumn = currentcollumn;
                saving_junction(currentjunctionrow,currentjunctioncollumn);
                if(currentrow == endrow){
                        if(matrix[currentrow][currentcollumn+1] == 1){
                            currentcollumn++;
                            adding_instructions('r');
                        }else if(matrix[currentrow][currentcollumn+1] == 0){
                            if((currentrow != 0) && (around_object == 0)){
                                sleep(1);
                                around_object = 1;
                                adding_instructions('u');

                                currentrow--;
                                currentrow--;
                                currentcollumn++;
                                adding_instructions('r');
                                currentcollumn++;
                                currentrow++;
                                currentrow++;
                                adding_instructions('d');

                                if(matrix[currentrow][currentcollumn] != 5){
                                    currentcollumn++;
                                		adding_instructions('r');
                                }
                                if(matrix[currentrow][currentcollumn+1] == 5){
                               currentcollumn++;
                               adding_instructions('0');
                              }
                            }else if((currentrow != 11) && (around_object == 0)){
                                sleep(1);
                                around_object = 1;
                                adding_instructions('d');
                                currentrow++;
                                currentrow++;
                                currentcollumn++;
                                adding_instructions('r');
                                currentcollumn++;
                                currentrow--;
                                currentrow--;
                                adding_instructions('u');
                                if(matrix[currentrow][currentcollumn] != 5){
                                    currentcollumn++;
                                		adding_instructions('r');
                                }}
                                if(matrix[currentrow][currentcollumn+1] == 5){
                               currentcollumn++;
                               adding_instructions('0');
                              }


                }}else{ //++
                    finding_route();
                    adding_instructions('u');
                    currentrow--;
                }
		}else if(matrix[currentrow][currentcollumn+1] == 5){
            currentcollumn++;
            adding_instructions('0');
            }}
	else if(currentcollumn > endcollumn){ //--
			if(matrix[currentrow][currentcollumn-1] == 1){
				currentcollumn--;
			}else if(matrix[currentrow][currentcollumn-1] == 4){
                currentcollumn--;
                adding_instructions('l');
                currentjunctionrow = currentrow;
                currentjunctioncollumn = currentcollumn;
                saving_junction(currentjunctionrow,currentjunctioncollumn);
                if(currentrow == endrow){
				if(matrix[currentrow][currentcollumn-1] == 1){
					currentcollumn--;
                    adding_instructions('l');
                }else if(matrix[currentrow][currentcollumn-1] == 0){
                            if((currentrow != 0) && (around_object == 0)){
                                sleep(1);
                                around_object = 1;
                                adding_instructions('u');
                                currentrow--;
                                currentrow--;
                                currentcollumn--;
                                adding_instructions('r');
                                currentcollumn--;
                                currentrow++;
                                currentrow++;
                                adding_instructions('d');
                                if(matrix[currentrow][currentcollumn] != 5){
                                    currentcollumn--;
                                		adding_instructions('r');
                                }
                                if(matrix[currentrow][currentcollumn-1] == 5){
                               currentcollumn--;
                               adding_instructions('0');
                              }
                            }else if((currentrow != 11) && (around_object == 0)){
                                sleep(1);
                                around_object = 1;
                                adding_instructions('u');
                                currentrow++;
                                currentrow++;
                                currentcollumn--;
                                adding_instructions('r');
                                currentcollumn--;
                                currentrow--;
                                currentrow--;
                                adding_instructions('d');
                                if(matrix[currentrow][currentcollumn-1] != 5){
                                    currentcollumn--;
                                adding_instructions('r');
                                }
                            	}}if(matrix[currentrow][currentcollumn-1] == 5){
                            				currentcollumn--;
                            				adding_instructions('0');
                        }

                }else{
                    finding_route();
                    adding_instructions('u');
                }
            }else if(matrix[currentrow][currentcollumn-1] == 5){
                    currentcollumn--;
                    adding_instructions('0');
            }
    }
    }




void finding_place(int place_number)
{
		for(int i = 0; i<11; i++){
    	for (int k = 0; k<10; k++){
    		if (matrix[i][k] ==place_number){
    			holding1 = i;
    			holding2 = k;
				}
			}
  	}
}

void get_places(){
    finding_place(2);
    startrow = holding1;
    startcollumn = holding2;
    finding_place(5);
    endrow = holding1;
    endcollumn = holding2;
    currentrow = startrow;
    currentcollumn = startcollumn;
		nxtDisplayTextLine(2, "%d, %d, %d, %d", startrow, startcollumn, endrow, endcollumn);
		wait(3);
}

void finding_route(){
	if(currentrow < endrow){ //++
		if(matrix[currentrow + 1][currentcollumn] == 1){
			currentcollumn++;
		}else if(matrix[currentrow+1][currentcollumn] == 4){
			currentrow++;
            currentjunctionrow = currentrow;
            currentjunctioncollumn = currentcollumn;
            saving_junction(currentjunctionrow,currentjunctioncollumn);
			if(currentrow != endrow){
			if(matrix[currentrow+1][currentcollumn] == 1){
				currentrow++;
                adding_instructions('u');
			}else{
                steering_sideways();
			}}
			else{
                steering_sideways();
				//sideways
			}
		}else if(matrix[currentrow+1][currentcollumn] == 5){
			currentrow++;
            adding_instructions('\0');
		}else if(matrix[currentrow+1][currentcollumn] == 0){
            steering_sideways();
        }
	}else if(currentrow > endrow){ //--
		if(matrix[currentrow - 1][currentcollumn] == 1){
			currentrow--;
		}else if(matrix[currentrow- 1][currentcollumn] == 4){
			currentrow--;
            currentjunctionrow = currentrow;
            currentjunctioncollumn = currentcollumn;
            saving_junction(currentjunctionrow,currentjunctioncollumn);
			if(currentrow != endrow){
			if(matrix[currentrow -1][currentcollumn] == 1){
				currentrow--;
                adding_instructions('u');
			}else{
                steering_sideways();
			}}
			else{
                steering_sideways();
				//sideways
			}
		}else if(matrix[currentrow-1][currentcollumn] == 5){
			currentrow--;
            adding_instructions('\0');
		}else if(matrix[currentrow-1][currentcollumn] == 0){
            steering_sideways();
        }
	}else if(currentrow == endrow){ //sideways
		steering_sideways();
}
}






task music() {
    //plays music while robot is in motion
    playSoundFile("Supermario.rmd");
    wait1Msec(10000);
}

void linefollow(void) {
    //using float variable for the sensors to have the most accurate
    float color;
    float light;
    float sonar;

    // reading the sensor value
    light = SensorValue[S2];
    color = SensorValue[S1];
    sonar = SensorValue[S3];

    // displaying the values from above
    //nxtDisplayTextLine(1, "color: %d", color);
    //nxtDisplayTextLine(2, "light: %d", light);
    //nxtDisplayTextLine(3, "sonar: %d", sonar);

    // if an object is closer then 30 centimeters do the folowing
    if (sonar < 10) {
    		nxtDisplayTextLine(2, "%lf", sonar);
        setMultipleMotors(0, motorA, motorB);
        wait(0.2);
        setMultipleMotors(-10, motorA, motorB);
        while (1) {//wait until you see the line
            if (SensorValue[S2] < 60) {
            		wait(1);
             		setMultipleMotors(0, motorA, motorB);
             		wait(2);
                break;
            }
        }
        tellen = 0;
        adjusting_for_object();
        nxtDisplayTextLine(1, "1");
        wait(1);
        get_places();
        nxtDisplayTextLine(1, "2");
        wait(1);
        memset(instructions, 0, 20);
        nxtDisplayTextLine(5, "[%d][%d] [%d][%d]", currentrow,currentcollumn,endrow,endcollumn);
        while(matrix[currentrow][currentcollumn] != matrix[endrow][endcollumn]){
    			finding_route();
    			nxtDisplayTextLine(3, "Finding route2.0");
    		}
    		memset(new_matrix, 0, 20);
    		calculate(0);
    		nxtDisplayTextLine(4, "calculating!");
    		nxtDisplayTextLine(0, "%c %c %c", instructions[0],instructions[1],instructions[2]);
    		nxtDisplayTextLine(4, "%c, %c,%c", new_matrix[0],new_matrix[1], new_matrix[2]);
    		counter = 0;
        //zet de 1 waarde van waar hij nu staat op 2 als begin en zet het ding na de kruising op 0 en bereken opnieuw de route en ga verder
    }        //redirect the robot by using the light sensor
     else if (light < (maxlight - 5)) {
        // float variable for the formule math
        float formule;
        float formule2;
        //omrek is used to can use the formules in every surroundings

    formule =speed+(speed / (maxlight-minlight))*(maxlight-light);
    formule2 = speed-(speed / (maxlight-minlight))*(maxlight-light);


        startTask(music); //starts the music
        // give the motor a and b the result of the formules
        motor(motorA) = formule; //50+((60-light)*2.5)
        motor(motorB) = formule2; //35  //0
    }        // redirecting the robot by using hte color sensor
    else if (color < (maxcolor - 5)) {//vorige waarde: 4
        // float variables for best accurate values
        float formule;

        float formule2;
        //omrek is used to can use the formules in every surroundings



              formule =speed+(speed / (maxcolor-mincolor))*(maxcolor-color);
    					formule2 = speed-(speed / (maxcolor-mincolor))*(maxcolor-color);


        startTask(music); //starts the music
        // give the motor a and b the result of the formules
        motor(motorA) = formule2; //0
        motor(motorB) = formule; //50+(50-color)*1+(2/3))
    } else {
        //if their isn't steering nessasary then both motors gets 50 as speed
        setMultipleMotors(speed, motorA, motorB); //70 //100
    }
}

void junction() {
    /*
            This code stops the robot at an intersection to make sure you can chose for it to go straight left or right.
            In case the direction is already chosen it just goes to the already chosen direction
     */

    if (SensorValue[S1] < (mincolor + 10) && SensorValue[S2] < (minlight + 10)) {//the minimul light value + 10 for the correct moment to stop at a line
    		setMultipleMotors(10, motorA, motorB); //Drive the cart forward a little for 50 miliseconds. This way it ends up more straight on the line after turning
        wait1Msec(100);
        stopTask(music); //stops the music
        clearSounds(); //clears the sound buffer
        //setMultipleMotors(0, motorA, motorB); //stop the robot
        //wait(1);

        while (1) {
        		nxtDisplayTextLine(0, "Counter: %d %c", counter, new_matrix[counter]);
            if (new_matrix[counter] == 'L') {//if the input is "LEFT" turn left until you read the black line color and then continue your normal duty
                motor(motorA) = 0;
                motor(motorB) = 40;
                while (1) {
                    if (SensorValue[S1] < 30) {//color sensor check
                        wait1Msec(5);
                        setMultipleMotors(0, motorA, motorB);
                        counter++;
                        break;
                    }
                }
                break;
            } else if (new_matrix[counter] == 'R') {//the same only then for turning right
                motor(motorA) = 40;
                motor(motorB) = 0;
                while (1) {
                    if (SensorValue[S2] < 50) {//light sensor check
                        wait1Msec(5);
                        setMultipleMotors(0, motorA, motorB);
                        counter++;
                        break;
                    }
                }
                break;
            }                //if up just stop the loop to exit
            else if (new_matrix[counter] == 'U') {
                setMultipleMotors(10, motorA, motorB);
                wait(0.2);
                counter++;
                break;
            }
        }
    }
}

task main() {
    /*
            The main function contains just an infinite while loop that continues to call all the functions before mentioned. In the called
            functions we check for specific things like the line curving or a bleutooth input.
     */
    nxtDisplayTextLine(0, "Start");
    get_places();
    nxtDisplayTextLine(1, "Map calibrated!");
    nxtDisplayTextLine(7, "[%d][%d][%d][%d]",startrow,startcollumn,endrow,endcollumn);

    while(matrix[currentrow][currentcollumn] != matrix[endrow][endcollumn]){
    	finding_route();
    	nxtDisplayTextLine(3, "Finding route");
    	nxtDisplayTextLine(6, "%d, %d", currentrow, currentcollumn);
    }
    nxtDisplayTextLine(5, "Calculating directions!");
    nxtDisplayTextLine(6, "%c %c %c ",instructions[0], instructions[1],instructions[2]);
    calculate(0);
    nxtDisplayTextLine(5, "Route Found!");
    nxtDisplayTextLine(2, "%c,%c,%c, %c,%c,%c", new_matrix[0], new_matrix[1], new_matrix[2],new_matrix[3],new_matrix[4],new_matrix[5]);
    int stopcode2 = 0; //for stopping the while loop in case of a remote code shutdown

    startTask(music); //start the music in a seperate thread

    counter = 0;

    while (1) {
        junction(); //check for an intersection
        linefollow(); //check if the line is curving and if not then just drive
        if (stopcode2 == 1) {//if "C" is pressed in the bleutooth_control function then stop the code completely
            return;
        }
    }
}
